<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Risk-Aware Control: Artifacts</title>
  
  <!-- Fonts: JetBrains Mono (Code) & Inter (UI) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>

  <!-- PrismJS (Syntax Highlighting) -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

  <link rel="stylesheet" href="assets/styles.css" />
  <script defer src="assets/app.js"></script>
</head>

<body>
  <div class="layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar__header">
        <div class="brand">ODU<span class="brand__accent">.ART</span></div>
        <div class="meta">M.Sc. Thesis â€¢ Jan 2026</div>
      </div>
      
      <nav class="nav">
        <span class="nav__label">Implementation</span>
        <a class="nav__item" href="#microarch">01. ODU Microarchitecture</a>
        <a class="nav__item" href="#gem5">02. gem5 Integration</a>
        
        <span class="nav__label">Validation</span>
        <a class="nav__item" href="#gadgets">03. Security Gadgets</a>
        <a class="nav__item" href="#metrics">04. SVF & Quantification</a>
        <a class="nav__item" href="#workloads">05. SPEC Workloads</a>
      </nav>
    </aside>

    <!-- Main -->
    <main class="content">
      <div class="container">
        
        <!-- Header -->
        <header class="header">
          <h1>Experimental Design & Artifacts</h1>
          <p class="lead">
            Technical documentation for the Risk-Aware Control Framework. 
            This page details the implementation of the ODU and the rigorous 
            testing methodology.
          </p>
        </header>

        <!-- 1. Microarchitecture -->
        <section id="microarch" class="section">
          <div class="section-head">
            <span class="mono">01</span>
            <h2>ODU Microarchitecture</h2>
          </div>
          
          <p>
            The core challenge is evaluating the utility equation in a single clock cycle during the Fetch stage. 
            Direct calculation is too slow. We implement a Log-Domain Comparator using Lookup Tables.
          </p>

          <div class="math-card">
            <div class="math-label">Target Inequality</div>
            \[ \pi(t) \cdot \mathcal{G} > (1 - \pi(t)) \cdot \mathcal{L} \]
            <div class="math-divider">Hardware Implementation (Log Domain)</div>
            \[ \underbrace{\log(\pi) - \log(1-\pi)}_{\text{LUT A (Odds)}} > \underbrace{\log(\mathcal{L}) - \log(\mathcal{G})}_{\text{LUT B (Cost)}} \]
          </div>

          <div class="callout">
            <strong>Why this is feasible:</strong> 
            We do not need precise floating-point math. We pre-compute <code>LUT A</code> (indexed by branch predictor confidence bits) 
            and <code>LUT B</code> (indexed by instruction type and cache hit/miss prediction). 
            The hardware cost is reduced to a single integer subtraction and comparison.
          </div>
        </section>

        <!-- 2. gem5 Integration -->
        <section id="gem5" class="section">
          <div class="section-head">
            <span class="mono">02</span>
            <h2>gem5 Implementation Strategy</h2>
          </div>
          <p>
            We modify the <code>FetchUnit</code> of the gem5 O3CPU model. The logic injects a 
            micro-architectural stall when risk exceeds utility.
          </p>

          <div class="code-block">
            <div class="code-header">src/cpu/o3/fetch.cc</div>
            <pre><code class="language-cpp">
// In Fetch::fetch(status_change)
bool Fetch::checkODU(DynInstPtr inst) {
    
    // 1. Get Hardware Confidence (Dynamic)
    // Map 2-bit or 3-bit saturating counter to probability range [0.0, 1.0]
    double pi = branchPred->getConfidence(inst->pc); 
    
    // 2. Get Instruction Leakage Class (Static)
    // 0 = Benign (ALU), 1 = Transmitter (Load/Store)
    // Derived from SVF methodology (Demme et al.)
    int L_tag = inst->staticInst->getLeakageClass(); 

    // 3. Estimate Gain (Dynamic)
    // Query MSHR (Miss Status Holding Register) for cache warmth
    bool is_hit = dcache->isLikelyHit(inst->addr);
    double G = is_hit ? GAIN_LOW : GAIN_HIGH;

    // 4. Fast Decision (LUT Based)
    // LUT_ODDS and LUT_COST are pre-computed arrays
    int32_t odds = LUT_ODDS[ convertToBin(pi) ];
    int32_t cost = LUT_COST[ L_tag ][ is_hit ];

    if (odds > cost) {
        return true; // Speculate
    } else {
        DPRINTF(ODU, "Risk Clamp: PC %x (Odds: %d, Cost: %d)\n", inst->pc, odds, cost);
        return false; // Stall Fetch
    }
}
            </code></pre>
          </div>
        </section>

        <!-- 3. Security Gadgets -->
        <section id="gadgets" class="section">
          <div class="section-head">
            <span class="mono">03</span>
            <h2>Security Validation</h2>
          </div>
          <p>
            To validate security, we must prove that the ODU reduces the SNR of a side-channel.
            We use the standard Spectre Variant 1 gadget.
          </p>

          <div class="tabs">
            <button class="tab active" onclick="setTab(event, 'gadget-c')">Victim Code (C)</button>
            <button class="tab" onclick="setTab(event, 'attack-c')">Attacker Code (C)</button>
          </div>

          <div id="gadget-c" class="tab-content active">
            <pre><code class="language-c">
// Victim Function (Spectre V1)
// The ODU must identify the risk in the speculative path.

void victim(size_t x) {
    if (x < array1_size) { 
        // 1. Branch Predictor is mistrained to take this path.
        // 2. 'x' is malicious (out of bounds).
        
        // This load depends on 'x'. 
        // ODU Analysis:
        // - Confidence (pi) is LOW (due to mistraining history).
        // - Leakage (L) is HIGH (Secret-dependent load).
        // -> RESULT: The ODU should STALL here.
        uint8_t secret = array1[x]; 
        
        // Transmitter: Modifies cache state based on secret
        temp &= array2[secret * 512];
    }
}
            </code></pre>
          </div>

          <div id="attack-c" class="tab-content">
            <pre><code class="language-c">
// Attacker Measurement (Flush + Reload)
// Based on Mastik / Yarom et al.

void measure_leakage() {
    // 1. Prime: Flush array2 from cache
    for (int i=0; i<256; i++) _mm_clflush(&array2[i*512]);

    // 2. Trigger: Call victim speculatively
    victim(malicious_x);

    // 3. Probe: Measure reload time
    for (int i=0; i<256; i++) {
        uint64_t t1 = __rdtscp(&junk);
        junk = array2[i*512];
        uint64_t t2 = __rdtscp(&junk) - t1;

        // If time < threshold, it was cached -> LEAK.
        // The ODU succeeds if this count remains near 0.
        if (t2 < CACHE_HIT_THRESHOLD) results[i]++;
    }
}
            </code></pre>
          </div>
        </section>

        <!-- 4. Metrics -->
        <section id="metrics" class="section">
          <div class="section-head">
            <span class="mono">04</span>
            <h2>Quantification Metrics</h2>
          </div>
          <p>
            Following Metior and SVF, we do not simply ask "did it leak?". We measure how much.
          </p>

          <div class="grid">
            <div class="card">
              <h3>Side-Channel Vulnerability Factor (SVF)</h3>
              <p>Measures the correlation between the Victim's execution pattern and the Attacker's observation.</p>
              <div class="metric-val">
                Target: SVF < 0.01
              </div>
              <p class="mono-xs">
                (Ideally 0.0, implying the attacker sees only noise).
              </p>
            </div>
            
            <div class="card">
              <h3>Transmission Rate</h3>
              <p>The raw bandwidth of the covert channel in Bits/Second under the ODU policy.</p>
              <div class="metric-val">
                Baseline: ~500 KB/s <br>
                Target: < 10 B/s
              </div>
            </div>
          </div>
        </section>

        <!-- 5. Workloads -->
        <section id="workloads" class="section">
          <div class="section-head">
            <span class="mono">05</span>
            <h2>Performance Workloads</h2>
          </div>
          <p>
            To prove the ODU is practical, we must show low overhead on benign code. 
            We use SPEC CPU2017 (Integer Speed).
          </p>

          <div class="code-block">
            <div class="code-header">Run Script (Bash)</div>
            <pre><code class="language-bash">
#!/bin/bash
# Sweep thresholds to generate the Pareto Frontier (Perf vs Security)

BENCHMARKS=("gcc" "mcf" "xalancbmk")
THRESHOLDS=("0.5" "1.0" "2.0") # Risk Tolerance

for bench in "${BENCHMARKS[@]}"; do
  for t in "${THRESHOLDS[@]}"; do
    
    ./build/X86/gem5.opt \
      --outdir=m5out/${bench}_T${t} \
      configs/example/se.py \
      --cpu-type=O3CPU \
      --caches --l2cache \
      --cmd=$bench \
      --odu-enabled \
      --odu-threshold=$t
      
  done
done
            </code></pre>
          </div>
        </section>

      </div>
    </main>
  </div>
</body>
</html>

