<!-- Main -->
    <main class="content">
      
      <!-- Header -->
      <header class="header">
        <h1>Experimental Design & Artifacts</h1>
        <p class="lead">
          Technical documentation for the <strong>Risk-Aware Control Framework</strong>. 
          This page details the implementation of the ODU and the rigorous testing methodology.
        </p>
      </header>

      <!-- 1. Microarch -->
      <section id="microarch" class="section">
        <div class="split">
          <!-- Left: Text -->
          <div class="text-col">
            <div class="section-head">
              <span class="mono">01</span>
              <h2>ODU Microarchitecture</h2>
            </div>
            <p>
              The core challenge is evaluating the utility equation in a single clock cycle during the Fetch stage. 
              Direct calculation involves division and floating point, which is too slow.
            </p>
            <p>
              We implement a <strong>Log-Domain Comparator</strong> using Lookup Tables (LUTs). This transforms the complex probability equation into a simple subtraction.
            </p>
            <div class="callout">
              <strong>Why this is feasible:</strong> 
              We pre-compute <code>LUT A</code> (indexed by branch predictor confidence bits) 
              and <code>LUT B</code> (indexed by instruction type). The hardware cost reduces to a single 
              <strong>integer subtraction</strong> on the critical path.
            </div>
          </div>

          <!-- Right: Visual -->
          <div class="visual-col">
            <div class="math-card">
              <div class="math-label">Target Inequality</div>
              \[ \pi(t) \cdot \mathcal{G} > (1 - \pi(t)) \cdot \mathcal{L} \]
              <div class="math-divider">Hardware Implementation (Log Domain)</div>
              \[ \underbrace{\log(\pi) - \log(1-\pi)}_{\text{LUT A (Odds)}} > \underbrace{\log(\mathcal{L}) - \log(\mathcal{G})}_{\text{LUT B (Cost)}} \]
            </div>
          </div>
        </div>
      </section>

      <!-- 2. gem5 Integration -->
      <section id="gem5" class="section">
        <div class="split">
          <!-- Left: Text -->
          <div class="text-col">
            <div class="section-head">
              <span class="mono">02</span>
              <h2>gem5 Implementation</h2>
            </div>
            <p>
              We modify the <code>FetchUnit</code> of the <strong>gem5 O3CPU</strong> model.
            </p>
            <p>
              The logic intercepts instructions before they enter the Decode stage. If the risk exceeds utility, 
              we inject a "micro-architectural stall" (bubble).
            </p>
            <h3>Key Modifications:</h3>
            <ul style="padding-left: 20px; color: var(--text-muted);">
              <li><strong>src/cpu/o3/fetch.cc</strong>: Main logic hook.</li>
              <li><strong>branch_pred/tournament.cc</strong>: Expose confidence counters.</li>
              <li><strong>mem/cache/base.cc</strong>: Expose MSHR status for Gain estimation.</li>
            </ul>
          </div>

          <!-- Right: Code -->
          <div class="visual-col">
            <div class="code-block">
              <div class="code-header">src/cpu/o3/fetch.cc (Proposed Modification)</div>
              <pre><code class="language-cpp">
// In Fetch::fetch(status_change)
bool Fetch::checkODU(DynInstPtr inst) {
    
    // 1. Hardware Confidence (Dynamic)
    double pi = branchPred->getConfidence(inst->pc); 
    
    // 2. Leakage Class (Static)
    // 0 = Benign (ALU), 1 = Transmitter (Load/Store)
    int L_tag = inst->staticInst->getLeakageClass(); 

    // 3. Gain (Dynamic) - Query MSHR
    bool is_hit = dcache->isLikelyHit(inst->addr);
    double G = is_hit ? GAIN_LOW : GAIN_HIGH;

    // 4. Fast Decision (LUT Based)
    int32_t odds = LUT_ODDS[ convertToBin(pi) ];
    int32_t cost = LUT_COST[ L_tag ][ is_hit ];

    if (odds > cost) return true; // Speculate
    
    DPRINTF(ODU, "Risk Clamp: PC %x\n", inst->pc);
    return false; // Stall Fetch
}
              </code></pre>
            </div>
          </div>
        </div>
      </section>

      <!-- 3. Security Gadgets -->
      <section id="gadgets" class="section">
        <div class="split">
          <div class="text-col">
            <div class="section-head">
              <span class="mono">03</span>
              <h2>Security Validation</h2>
            </div>
            <p>
              To validate security, we must prove that the ODU reduces the <strong>Signal-to-Noise Ratio (SNR)</strong> of a side-channel.
            </p>
            <p>
              We use the standard <em>Spectre Variant 1</em> gadget. We confirm the attack works on the baseline (Unsafe) gem5, 
              then measure the Bitrate reduction when ODU is enabled.
            </p>
          </div>

          <div class="visual-col">
            <div class="tabs">
              <button class="tab active" onclick="setTab(event, 'gadget-c')">Victim Code (C)</button>
              <button class="tab" onclick="setTab(event, 'attack-c')">Attacker Code (C)</button>
            </div>

            <div id="gadget-c" class="tab-content active">
              <pre><code class="language-c">
// Victim Function (Spectre V1)
void victim(size_t x) {
    if (x < array1_size) { 
        // 1. Branch Predictor is mistrained.
        // 2. 'x' is malicious (out of bounds).
        
        // ODU Analysis:
        // - Confidence (pi) is LOW.
        // - Leakage (L) is HIGH (Secret load).
        // -> RESULT: The ODU should STALL here.
        uint8_t secret = array1[x]; 
        
        // Transmitter
        temp &= array2[secret * 512];
    }
}
              </code></pre>
            </div>

            <div id="attack-c" class="tab-content">
              <pre><code class="language-c">
// Attacker Measurement (Flush + Reload)
void measure_leakage() {
    // 1. Prime
    for (int i=0; i<256; i++) _mm_clflush(&array2[i*512]);

    // 2. Trigger (Speculative)
    victim(malicious_x);

    // 3. Probe
    for (int i=0; i<256; i++) {
        uint64_t t1 = __rdtscp(&junk);
        junk = array2[i*512];
        uint64_t t2 = __rdtscp(&junk) - t1;

        // If fast, it was cached -> LEAK.
        if (t2 < CACHE_HIT_THRESHOLD) results[i]++;
    }
}
              </code></pre>
            </div>
          </div>
        </div>
      </section>

      <!-- 4. Metrics -->
      <section id="metrics" class="section">
        <div class="section-head">
          <span class="mono">04</span>
          <h2>Quantification Metrics</h2>
        </div>
        <p style="margin-bottom: 2rem;">
          Following <em>Metior</em> and <em>SVF</em>, we do not simply ask "did it leak?". We measure <strong>how much</strong>.
        </p>

        <div class="grid">
          <div class="card">
            <h3>Side-Channel Vuln. Factor (SVF)</h3>
            <p>Correlation between Victim execution pattern and Attacker observation.</p>
            <div class="metric-val">Target: SVF < 0.01</div>
            <p class="mono-xs">(Ideally 0.0, implying pure noise).</p>
          </div>
          
          <div class="card">
            <h3>Transmission Rate</h3>
            <p>Raw bandwidth of the covert channel.</p>
            <div class="metric-val">
              Baseline: ~500 KB/s <br>
              Target: < 10 B/s
            </div>
          </div>

          <div class="card">
            <h3>Performance Overhead</h3>
            <p>Impact on SPEC CPU2017 (Integer).</p>
            <div class="metric-val">Target: < 10% Slowdown</div>
          </div>
        </div>
      </section>

      <!-- 5. Workloads -->
      <section id="workloads" class="section">
        <div class="split">
          <div class="text-col">
            <div class="section-head">
              <span class="mono">05</span>
              <h2>Performance Workloads</h2>
            </div>
            <p>
              To prove the ODU is practical, we run <strong>SPEC CPU2017</strong> benchmarks. We perform a parameter sweep on the `odu-threshold` to find the Pareto Frontier.
            </p>
          </div>

          <div class="visual-col">
            <div class="code-block">
              <div class="code-header">Run Script (Bash)</div>
              <pre><code class="language-bash">
#!/bin/bash
BENCHMARKS=("gcc" "mcf" "xalancbmk")
THRESHOLDS=("0.5" "1.0" "2.0") 

for bench in "${BENCHMARKS[@]}"; do
  for t in "${THRESHOLDS[@]}"; do
    
    ./build/X86/gem5.opt \
      --outdir=m5out/${bench}_T${t} \
      configs/example/se.py \
      --cpu-type=O3CPU \
      --caches --l2cache \
      --cmd=$bench \
      --odu-enabled \
      --odu-threshold=$t
      
  done
done
              </code></pre>
            </div>
          </div>
        </div>
      </section>

    </main>
